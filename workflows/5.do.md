# ç¨Žå‹™æ›¸é¡žãƒªãƒãƒ¼ãƒžãƒ¼ã‚·ã‚¹ãƒ†ãƒ  - å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º v5.3.5-ui-robust

## æ¦‚è¦
ä½“ç³»çš„ãªå®Ÿè£…å®Ÿè¡Œç®¡ç†ã¨ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«å“è³ªä¿è¨¼ãƒ—ãƒ­ã‚»ã‚¹

## 1. å®Ÿè£…å‰æº–å‚™ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### ç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ¤œè¨¼
```bash
# é–‹ç™ºç’°å¢ƒæ¤œè¨¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
python --version  # >= 3.11
pip list | grep -E "(pytest|black|flake8|mypy)"
git status  # clean working directory
```

### å®Ÿè£…å¯¾è±¡ç¢ºèª
```yaml
å®Ÿè£…ã‚¹ã‚³ãƒ¼ãƒ—ç¢ºèª:
  - åˆ†æžå®Œäº†: "âœ… workflows/1.analyze.md"
  - è¨ˆç”»æ‰¿èª: "âœ… workflows/2.plan.md"
  - ãƒã‚§ãƒƒã‚¯å®Œäº†: "âœ… workflows/3.check.md"
  - è©•ä¾¡å®Œäº†: "âœ… workflows/4.eval.md"
  - å®Ÿè£…ç€æ‰‹: "ðŸš€ workflows/5.do.md"
```

## 2. æ®µéšŽçš„å®Ÿè£…æˆ¦ç•¥

### Phase 0: åŸºç›¤ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ•´å‚™

#### åž‹ãƒ’ãƒ³ãƒˆå®Œå…¨é©ç”¨
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: åž‹ãƒ’ãƒ³ãƒˆè¿½åŠ 
from typing import Optional, Dict, List, Union, Any
from dataclasses import dataclass
from pathlib import Path

# Before
def process_file(file_path, settings):
    pass

# After
def process_file(
    file_path: Path, 
    settings: Dict[str, Any]
) -> Optional[Dict[str, str]]:
    pass
```

#### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: ä¾‹å¤–éšŽå±¤æ§‹ç¯‰
class TaxDocumentError(Exception):
    """ç¨Žå‹™æ›¸é¡žå‡¦ç†åŸºåº•ä¾‹å¤–"""
    pass

class YYMMValidationError(TaxDocumentError):
    """YYMMæ¤œè¨¼ã‚¨ãƒ©ãƒ¼"""
    pass

class BundleProcessingError(TaxDocumentError):
    """Bundleå‡¦ç†ã‚¨ãƒ©ãƒ¼"""
    pass

class UIForcedCodeError(TaxDocumentError):
    """UIå¼·åˆ¶ã‚³ãƒ¼ãƒ‰å‡¦ç†ã‚¨ãƒ©ãƒ¼"""
    pass
```

#### ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ æ¨™æº–åŒ–
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: æ§‹é€ åŒ–ãƒ­ã‚°å°Žå…¥
import structlog
from helpers.job_context import JobContext

# ãƒ­ã‚°è¨­å®š
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer(ensure_ascii=False)
    ],
    wrapper_class=structlog.stdlib.BoundLogger,
    logger_factory=structlog.stdlib.LoggerFactory(),
    cache_logger_on_first_use=True,
)

# ä½¿ç”¨ä¾‹
logger = structlog.get_logger("tax_document")
logger.info(
    "YYMMå‡¦ç†å®Œäº†",
    job_id=job_context.job_id,
    yymm=job_context.confirmed_yymm,
    source=job_context.yymm_source,
    processing_time=elapsed_time
)
```

### Phase 1: ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°

#### ã‚µãƒ¼ãƒ“ã‚¹å±¤åˆ†é›¢
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: DocumentProcessingServiceä½œæˆ
from abc import ABC, abstractmethod
from helpers.job_context import JobContext
from helpers.run_config import RunConfig

class DocumentProcessingService(ABC):
    """æ–‡æ›¸å‡¦ç†ã‚µãƒ¼ãƒ“ã‚¹åŸºåº•ã‚¯ãƒ©ã‚¹"""
    
    @abstractmethod
    def process_document(
        self, 
        file_path: Path, 
        job_context: JobContext
    ) -> Dict[str, Any]:
        pass

class TaxDocumentProcessingService(DocumentProcessingService):
    """ç¨Žå‹™æ›¸é¡žå‡¦ç†ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…"""
    
    def __init__(
        self,
        classifier: DocumentClassifierV5,
        pdf_processor: PDFProcessor,
        yymm_resolver: YYMMResolver
    ):
        self.classifier = classifier
        self.pdf_processor = pdf_processor
        self.yymm_resolver = yymm_resolver
    
    def process_document(
        self, 
        file_path: Path, 
        job_context: JobContext
    ) -> Dict[str, Any]:
        # å®Ÿè£…è©³ç´°
        pass
```

#### ä¾å­˜æ€§æ³¨å…¥ã‚³ãƒ³ãƒ†ãƒŠ
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: DI Containeræ§‹ç¯‰
from dependency_injector import containers, providers
from dependency_injector.wiring import Provide, inject

class ApplicationContainer(containers.DeclarativeContainer):
    """ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä¾å­˜æ€§ã‚³ãƒ³ãƒ†ãƒŠ"""
    
    # è¨­å®š
    config = providers.Configuration()
    
    # ãƒªãƒã‚¸ãƒˆãƒª
    file_repository = providers.Singleton(FileSystemRepository)
    
    # ã‚µãƒ¼ãƒ“ã‚¹
    pdf_processor = providers.Factory(PDFProcessor)
    classifier = providers.Factory(DocumentClassifierV5)
    yymm_resolver = providers.Factory(YYMMResolver)
    
    document_service = providers.Factory(
        TaxDocumentProcessingService,
        classifier=classifier,
        pdf_processor=pdf_processor,
        yymm_resolver=yymm_resolver
    )
    
    # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
    main_app = providers.Factory(
        TaxDocumentRenamerApp,
        document_service=document_service
    )

# ä½¿ç”¨ä¾‹
@inject
def main(
    app: TaxDocumentRenamerApp = Provide[ApplicationContainer.main_app]
):
    app.run()
```

### Phase 2: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹æœ€é©åŒ–

#### éžåŒæœŸå‡¦ç†å°Žå…¥
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: éžåŒæœŸPDFå‡¦ç†
import asyncio
from concurrent.futures import ThreadPoolExecutor
from typing import AsyncGenerator

class AsyncPDFProcessor:
    """éžåŒæœŸPDFå‡¦ç†ã‚¨ãƒ³ã‚¸ãƒ³"""
    
    def __init__(self, max_workers: int = 4):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def process_pdf_async(
        self, 
        file_path: Path,
        job_context: JobContext
    ) -> Dict[str, Any]:
        """éžåŒæœŸPDFå‡¦ç†"""
        loop = asyncio.get_event_loop()
        
        # CPUé›†ç´„çš„ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã§å®Ÿè¡Œ
        result = await loop.run_in_executor(
            self.executor,
            self._process_pdf_sync,
            file_path,
            job_context
        )
        
        return result
    
    async def process_multiple_pdfs(
        self,
        file_paths: List[Path],
        job_context: JobContext
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """è¤‡æ•°PDFä¸¦åˆ—å‡¦ç†"""
        tasks = [
            self.process_pdf_async(path, job_context) 
            for path in file_paths
        ]
        
        # å®Œäº†æ¬¡ç¬¬çµæžœã‚’è¿”ã™
        for task in asyncio.as_completed(tasks):
            result = await task
            yield result
```

#### ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ å°Žå…¥
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥
from functools import lru_cache
from typing import Dict, Any
import hashlib
import pickle

class DocumentClassificationCache:
    """æ–‡æ›¸åˆ†é¡žçµæžœã‚­ãƒ£ãƒƒã‚·ãƒ¥"""
    
    def __init__(self, cache_size: int = 1000):
        self.cache_size = cache_size
        self._memory_cache = {}
    
    def _generate_cache_key(
        self, 
        text: str, 
        filename: str,
        settings: Dict[str, Any]
    ) -> str:
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ç”Ÿæˆ"""
        content = f"{text}|{filename}|{str(sorted(settings.items()))}"
        return hashlib.sha256(content.encode()).hexdigest()[:16]
    
    @lru_cache(maxsize=1000)
    def get_classification_cached(
        self, 
        text_hash: str,
        filename: str,
        settings_hash: str
    ) -> Optional[Dict[str, Any]]:
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰åˆ†é¡žçµæžœå–å¾—"""
        cache_key = f"{text_hash}|{filename}|{settings_hash}"
        return self._memory_cache.get(cache_key)
    
    def set_classification_cache(
        self,
        text_hash: str,
        filename: str, 
        settings_hash: str,
        result: Dict[str, Any]
    ):
        """åˆ†é¡žçµæžœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜"""
        cache_key = f"{text_hash}|{filename}|{settings_hash}"
        
        # LRU eviction
        if len(self._memory_cache) >= self.cache_size:
            oldest_key = next(iter(self._memory_cache))
            del self._memory_cache[oldest_key]
        
        self._memory_cache[cache_key] = result
```

### Phase 3: ãƒ†ã‚¹ãƒˆãƒ»å“è³ªä¿è¨¼

#### åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æ§‹ç¯‰
import pytest
from unittest.mock import Mock, patch
from helpers.job_context import JobContext
from helpers.run_config import RunConfig

class TestTaxDocumentProcessing:
    """ç¨Žå‹™æ›¸é¡žå‡¦ç†ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ"""
    
    @pytest.fixture
    def sample_job_context(self):
        run_config = RunConfig.from_ui_input("2508")
        return JobContext(
            job_id="test_job_001",
            confirmed_yymm="2508", 
            yymm_source="UI",
            run_config=run_config
        )
    
    @pytest.fixture
    def sample_pdf_file(self, tmp_path):
        """ãƒ†ã‚¹ãƒˆç”¨PDFãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ"""
        pdf_path = tmp_path / "test_document.pdf"
        # PDFãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆãƒ­ã‚¸ãƒƒã‚¯
        return pdf_path
    
    def test_ui_forced_code_validation(self, sample_job_context):
        """UIå¼·åˆ¶ã‚³ãƒ¼ãƒ‰æ¤œè¨¼ãƒ†ã‚¹ãƒˆ"""
        # 6001ã‚³ãƒ¼ãƒ‰ã§UIå€¤ãŒç¢ºå®Ÿã«é©ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
        yymm = sample_job_context.get_yymm_for_classification("6001")
        assert yymm == "2508"
        
        # UIå€¤ãŒãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼ç¢ºèª
        empty_context = JobContext(
            job_id="test_empty",
            confirmed_yymm=None,
            yymm_source="NONE",
            run_config=None
        )
        
        with pytest.raises(ValueError, match="UI YYMM required"):
            empty_context.get_yymm_for_classification("6001")
    
    @pytest.mark.asyncio
    async def test_async_pdf_processing(
        self, 
        sample_pdf_file, 
        sample_job_context
    ):
        """éžåŒæœŸPDFå‡¦ç†ãƒ†ã‚¹ãƒˆ"""
        processor = AsyncPDFProcessor()
        result = await processor.process_pdf_async(
            sample_pdf_file, 
            sample_job_context
        )
        
        assert result is not None
        assert "processing_time" in result
        
    def test_bundle_split_propagation(self, sample_pdf_file):
        """Bundleåˆ†å‰²ã§ã®RunConfigä¼æ¬ãƒ†ã‚¹ãƒˆ"""
        # Bundleåˆ†å‰²ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§RunConfigæƒ…å ±ãŒ
        # ç¢ºå®Ÿã«ä¼æ¬ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
        pass
```

#### çµ±åˆãƒ†ã‚¹ãƒˆãƒ»E2Eãƒ†ã‚¹ãƒˆ
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: E2Eãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ª
class TestTaxDocumentE2E:
    """ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ"""
    
    def test_complete_processing_workflow(self, tmp_path):
        """å®Œå…¨å‡¦ç†ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ"""
        # 1. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•
        # 2. UIå€¤è¨­å®š (2508)
        # 3. PDFå‡¦ç†å®Ÿè¡Œ
        # 4. UIå¼·åˆ¶ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«åç¢ºèª
        # 5. Bundleåˆ†å‰²çµæžœç¢ºèª
        # 6. ãƒ­ã‚°å‡ºåŠ›ç¢ºèª
        pass
        
    def test_error_recovery_scenarios(self):
        """ã‚¨ãƒ©ãƒ¼å›žå¾©ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆ"""
        # 1. UIå€¤æœªè¨­å®šã‚¨ãƒ©ãƒ¼
        # 2. ä¸æ­£ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚¨ãƒ©ãƒ¼  
        # 3. Bundleåˆ†å‰²å¤±æ•—
        # 4. ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³
        pass
```

## 3. å®Ÿè¡Œãƒ­ã‚°ãƒ»é€²æ—è¨˜éŒ²

### å®Ÿè£…é€²æ—ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: é€²æ—è¨˜éŒ²ã‚·ã‚¹ãƒ†ãƒ 
from datetime import datetime
from typing import Dict, List
import json

class ImplementationTracker:
    """å®Ÿè£…é€²æ—è¿½è·¡ã‚·ã‚¹ãƒ†ãƒ """
    
    def __init__(self, project_name: str):
        self.project_name = project_name
        self.start_time = datetime.now()
        self.tasks = []
        self.milestones = []
    
    def start_task(self, task_name: str, description: str):
        """ã‚¿ã‚¹ã‚¯é–‹å§‹è¨˜éŒ²"""
        task = {
            "name": task_name,
            "description": description,
            "start_time": datetime.now().isoformat(),
            "status": "in_progress",
            "end_time": None,
            "duration": None,
            "notes": []
        }
        self.tasks.append(task)
        return len(self.tasks) - 1  # task index
    
    def complete_task(self, task_index: int, notes: str = ""):
        """ã‚¿ã‚¹ã‚¯å®Œäº†è¨˜éŒ²"""
        task = self.tasks[task_index]
        task["end_time"] = datetime.now().isoformat()
        task["status"] = "completed"
        task["duration"] = (
            datetime.fromisoformat(task["end_time"]) - 
            datetime.fromisoformat(task["start_time"])
        ).total_seconds()
        if notes:
            task["notes"].append(notes)
    
    def add_milestone(self, milestone_name: str, achievement: str):
        """ãƒžã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³è¨˜éŒ²"""
        milestone = {
            "name": milestone_name,
            "achievement": achievement,
            "timestamp": datetime.now().isoformat(),
            "completed_tasks": len([t for t in self.tasks if t["status"] == "completed"])
        }
        self.milestones.append(milestone)
    
    def generate_progress_report(self) -> str:
        """é€²æ—ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_path = f"tmp/implementation_progress_{timestamp}.md"
        
        total_tasks = len(self.tasks)
        completed_tasks = len([t for t in self.tasks if t["status"] == "completed"])
        progress_percentage = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
        
        report_data = {
            "project": self.project_name,
            "progress": f"{progress_percentage:.1f}%",
            "tasks": {
                "total": total_tasks,
                "completed": completed_tasks,
                "in_progress": len([t for t in self.tasks if t["status"] == "in_progress"])
            },
            "milestones": self.milestones,
            "detailed_tasks": self.tasks
        }
        
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(f"# {self.project_name} å®Ÿè£…é€²æ—ãƒ¬ãƒãƒ¼ãƒˆ\n\n")
            f.write(f"ç”Ÿæˆæ—¥æ™‚: {timestamp}\n")
            f.write(f"é€²æ—çŽ‡: {progress_percentage:.1f}%\n\n")
            f.write("```json\n")
            f.write(json.dumps(report_data, ensure_ascii=False, indent=2))
            f.write("\n```\n")
        
        return report_path

# ä½¿ç”¨ä¾‹
tracker = ImplementationTracker("ç¨Žå‹™æ›¸é¡žãƒªãƒãƒ¼ãƒžãƒ¼ v5.3.5-ui-robust")

# Phase 0 å®Ÿè£…
task_idx = tracker.start_task("åž‹ãƒ’ãƒ³ãƒˆè¿½åŠ ", "å…¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«åž‹ãƒ’ãƒ³ãƒˆé©ç”¨")
# ... å®Ÿè£…ä½œæ¥­ ...
tracker.complete_task(task_idx, "main.py, helpers/*.pyå®Œäº†")

tracker.add_milestone("Phase 0å®Œäº†", "åŸºç›¤æ•´å‚™å®Œäº†ãƒ»åž‹å®‰å…¨æ€§ç¢ºç«‹")
```

## 4. å“è³ªãƒã‚§ãƒƒã‚¯ãƒ»ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼

### è‡ªå‹•å“è³ªãƒã‚§ãƒƒã‚¯
```bash
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: å“è³ªãƒã‚§ãƒƒã‚¯è‡ªå‹•åŒ–
#!/bin/bash
# quality_check.sh

echo "ðŸ” ç¨Žå‹™æ›¸é¡žãƒªãƒãƒ¼ãƒžãƒ¼å“è³ªãƒã‚§ãƒƒã‚¯é–‹å§‹"

# åž‹ãƒã‚§ãƒƒã‚¯
echo "ðŸ“ åž‹ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œä¸­..."
mypy --strict **/*.py

# ã‚³ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«
echo "ðŸŽ¨ ã‚³ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«ãƒã‚§ãƒƒã‚¯..."
black --check **/*.py
flake8 **/*.py

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
echo "ðŸ§ª ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­..."
pytest tests/ -v --cov=. --cov-report=html

# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
echo "ðŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯..."
bandit -r . -f json -o tmp/security_report.json

# è¤‡é›‘åº¦ãƒã‚§ãƒƒã‚¯
echo "ðŸ“Š ã‚³ãƒ¼ãƒ‰è¤‡é›‘åº¦ãƒã‚§ãƒƒã‚¯..."
radon cc . --min B --json > tmp/complexity_report.json

echo "âœ… å“è³ªãƒã‚§ãƒƒã‚¯å®Œäº†"
```

### ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
```yaml
ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦³ç‚¹:
  æ©Ÿèƒ½æ€§:
    - [ ] UIå¼·åˆ¶ã‚³ãƒ¼ãƒ‰ï¼ˆ6001,6002,6003,0000ï¼‰æ­£å¸¸å‹•ä½œ
    - [ ] Bundleåˆ†å‰²ã§RunConfigä¼æ¬ç¢ºèª
    - [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°é©åˆ‡æ€§
    - [ ] ãƒ­ã‚°å‡ºåŠ›å¦¥å½“æ€§
  
  å“è³ª:
    - [ ] åž‹ãƒ’ãƒ³ãƒˆå®Œå…¨é©ç”¨
    - [ ] ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ >= 90%
    - [ ] ã‚³ãƒ¼ãƒ‰è¤‡é›‘åº¦ <= 10
    - [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆé©åˆ‡æ€§
  
  ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£:
    - [ ] å…¥åŠ›æ¤œè¨¼å®Ÿè£…
    - [ ] æ©Ÿå¯†æƒ…å ±æ¼æ´©é˜²æ­¢
    - [ ] ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
    - [ ] ã‚¨ãƒ©ãƒ¼æƒ…å ±é©åˆ‡åˆ¶å¾¡
  
  ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹:
    - [ ] ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ç„¡ã—
    - [ ] å‡¦ç†æ™‚é–“è¦ä»¶é”æˆ
    - [ ] ãƒªã‚½ãƒ¼ã‚¹åŠ¹çŽ‡åˆ©ç”¨
    - [ ] ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£è€ƒæ…®
```

## 5. å®Œäº†åŸºæº–ãƒ»æ¤œåŽæ¡ä»¶

### å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
```yaml
Phase 0 å®Œäº†åŸºæº–:
  - [ ] åž‹ãƒ’ãƒ³ãƒˆ100%é©ç”¨å®Œäº†
  - [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä½“ç³»æ§‹ç¯‰
  - [ ] æ§‹é€ åŒ–ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ å°Žå…¥
  - [ ] è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆä½œæˆ

Phase 1 å®Œäº†åŸºæº–:
  - [ ] ã‚µãƒ¼ãƒ“ã‚¹å±¤åˆ†é›¢å®Œäº†
  - [ ] ä¾å­˜æ€§æ³¨å…¥ã‚³ãƒ³ãƒ†ãƒŠæ§‹ç¯‰
  - [ ] ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
  - [ ] ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¢ƒç•Œæ˜Žç¢ºåŒ–

Phase 2 å®Œäº†åŸºæº–:
  - [ ] éžåŒæœŸå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ å°Žå…¥
  - [ ] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…
  - [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹ç›®æ¨™é”æˆ
  - [ ] ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ç¢ºä¿

å…¨ä½“å®Œäº†åŸºæº–:
  - [ ] å…¨ãƒ†ã‚¹ãƒˆé …ç›®PASS
  - [ ] å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹ç›®æ¨™é”æˆ
  - [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶å……è¶³
  - [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå®Œå‚™
```

### æ¤œåŽã‚·ãƒŠãƒªã‚ª
```python
# å®Ÿè£…ã‚¿ã‚¹ã‚¯: å—å…¥ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ª
def acceptance_test_scenario():
    """å—å…¥ãƒ†ã‚¹ãƒˆå®Œå…¨ã‚·ãƒŠãƒªã‚ª"""
    scenarios = [
        {
            "name": "UI=2508ã§ã®UIå¼·åˆ¶ã‚³ãƒ¼ãƒ‰å‡¦ç†",
            "steps": [
                "ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•",
                "YYMMå€¤ã«2508ã‚’è¨­å®š",
                "6001,6002,6003,0000ã‚’å«ã‚€PDFå‡¦ç†",
                "ç¢ºå®Ÿãª_2508ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆç¢ºèª"
            ],
            "expected": "å…¨UIå¼·åˆ¶ã‚³ãƒ¼ãƒ‰ã§_2508ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ"
        },
        {
            "name": "Bundleåˆ†å‰²ã§ã®RunConfigä¼æ¬",
            "steps": [
                "Bundle PDFæº–å‚™",
                "UIå€¤è¨­å®š",
                "è‡ªå‹•åˆ†å‰²å®Ÿè¡Œ",
                "åˆ†å‰²å¾Œå„ãƒ•ã‚¡ã‚¤ãƒ«ã®YYMMå€¤ç¢ºèª"
            ],
            "expected": "åˆ†å‰²ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«å…¨ã¦ã«YYMMå€¤ä¼æ¬"
        },
        {
            "name": "ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»å›žå¾©",
            "steps": [
                "UIå€¤æœªè¨­å®šçŠ¶æ…‹ã§UIå¼·åˆ¶ã‚³ãƒ¼ãƒ‰å‡¦ç†",
                "é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºç¢ºèª",
                "ã‚·ã‚¹ãƒ†ãƒ å®‰å®šæ€§ç¢ºèª"
            ],
            "expected": "é©åˆ‡ãªã‚¨ãƒ©ãƒ¼å‡¦ç†ãƒ»ã‚·ã‚¹ãƒ†ãƒ ç¶™ç¶šå‹•ä½œ"
        }
    ]
    return scenarios
```

---

**å®Ÿè£…ãƒ¢ãƒƒãƒˆãƒ¼**: "Code with Pride, Test with Rigor, Deploy with Confidenceï¼"  
**å®Œäº†åŸºæº–**: å…¨ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆé …ç›®å®Œäº† + å—å…¥ãƒ†ã‚¹ãƒˆå…¨PASS + å“è³ªåŸºæº–é”æˆ