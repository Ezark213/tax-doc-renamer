# 税務書類リネーマーシステム - 実装フェーズ v5.3.5-ui-robust

## 概要
体系的な実装実行管理とプロフェッショナル品質保証プロセス

## 1. 実装前準備チェックリスト

### 環境セットアップ検証
```bash
# 開発環境検証スクリプト
python --version  # >= 3.11
pip list | grep -E "(pytest|black|flake8|mypy)"
git status  # clean working directory
```

### 実装対象確認
```yaml
実装スコープ確認:
  - 分析完了: "✅ workflows/1.analyze.md"
  - 計画承認: "✅ workflows/2.plan.md"
  - チェック完了: "✅ workflows/3.check.md"
  - 評価完了: "✅ workflows/4.eval.md"
  - 実装着手: "🚀 workflows/5.do.md"
```

## 2. 段階的実装戦略

### Phase 0: 基盤コンポーネント整備

#### 型ヒント完全適用
```python
# 実装タスク: 型ヒント追加
from typing import Optional, Dict, List, Union, Any
from dataclasses import dataclass
from pathlib import Path

# Before
def process_file(file_path, settings):
    pass

# After
def process_file(
    file_path: Path, 
    settings: Dict[str, Any]
) -> Optional[Dict[str, str]]:
    pass
```

#### エラーハンドリング強化
```python
# 実装タスク: 例外階層構築
class TaxDocumentError(Exception):
    """税務書類処理基底例外"""
    pass

class YYMMValidationError(TaxDocumentError):
    """YYMM検証エラー"""
    pass

class BundleProcessingError(TaxDocumentError):
    """Bundle処理エラー"""
    pass

class UIForcedCodeError(TaxDocumentError):
    """UI強制コード処理エラー"""
    pass
```

#### ログシステム標準化
```python
# 実装タスク: 構造化ログ導入
import structlog
from helpers.job_context import JobContext

# ログ設定
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer(ensure_ascii=False)
    ],
    wrapper_class=structlog.stdlib.BoundLogger,
    logger_factory=structlog.stdlib.LoggerFactory(),
    cache_logger_on_first_use=True,
)

# 使用例
logger = structlog.get_logger("tax_document")
logger.info(
    "YYMM処理完了",
    job_id=job_context.job_id,
    yymm=job_context.confirmed_yymm,
    source=job_context.yymm_source,
    processing_time=elapsed_time
)
```

### Phase 1: アーキテクチャリファクタリング

#### サービス層分離
```python
# 実装タスク: DocumentProcessingService作成
from abc import ABC, abstractmethod
from helpers.job_context import JobContext
from helpers.run_config import RunConfig

class DocumentProcessingService(ABC):
    """文書処理サービス基底クラス"""
    
    @abstractmethod
    def process_document(
        self, 
        file_path: Path, 
        job_context: JobContext
    ) -> Dict[str, Any]:
        pass

class TaxDocumentProcessingService(DocumentProcessingService):
    """税務書類処理サービス実装"""
    
    def __init__(
        self,
        classifier: DocumentClassifierV5,
        pdf_processor: PDFProcessor,
        yymm_resolver: YYMMResolver
    ):
        self.classifier = classifier
        self.pdf_processor = pdf_processor
        self.yymm_resolver = yymm_resolver
    
    def process_document(
        self, 
        file_path: Path, 
        job_context: JobContext
    ) -> Dict[str, Any]:
        # 実装詳細
        pass
```

#### 依存性注入コンテナ
```python
# 実装タスク: DI Container構築
from dependency_injector import containers, providers
from dependency_injector.wiring import Provide, inject

class ApplicationContainer(containers.DeclarativeContainer):
    """アプリケーション依存性コンテナ"""
    
    # 設定
    config = providers.Configuration()
    
    # リポジトリ
    file_repository = providers.Singleton(FileSystemRepository)
    
    # サービス
    pdf_processor = providers.Factory(PDFProcessor)
    classifier = providers.Factory(DocumentClassifierV5)
    yymm_resolver = providers.Factory(YYMMResolver)
    
    document_service = providers.Factory(
        TaxDocumentProcessingService,
        classifier=classifier,
        pdf_processor=pdf_processor,
        yymm_resolver=yymm_resolver
    )
    
    # アプリケーション
    main_app = providers.Factory(
        TaxDocumentRenamerApp,
        document_service=document_service
    )

# 使用例
@inject
def main(
    app: TaxDocumentRenamerApp = Provide[ApplicationContainer.main_app]
):
    app.run()
```

### Phase 2: パフォーマンス最適化

#### 非同期処理導入
```python
# 実装タスク: 非同期PDF処理
import asyncio
from concurrent.futures import ThreadPoolExecutor
from typing import AsyncGenerator

class AsyncPDFProcessor:
    """非同期PDF処理エンジン"""
    
    def __init__(self, max_workers: int = 4):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def process_pdf_async(
        self, 
        file_path: Path,
        job_context: JobContext
    ) -> Dict[str, Any]:
        """非同期PDF処理"""
        loop = asyncio.get_event_loop()
        
        # CPU集約的タスクをスレッドプールで実行
        result = await loop.run_in_executor(
            self.executor,
            self._process_pdf_sync,
            file_path,
            job_context
        )
        
        return result
    
    async def process_multiple_pdfs(
        self,
        file_paths: List[Path],
        job_context: JobContext
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """複数PDF並列処理"""
        tasks = [
            self.process_pdf_async(path, job_context) 
            for path in file_paths
        ]
        
        # 完了次第結果を返す
        for task in asyncio.as_completed(tasks):
            result = await task
            yield result
```

#### キャッシュシステム導入
```python
# 実装タスク: インテリジェントキャッシュ
from functools import lru_cache
from typing import Dict, Any
import hashlib
import pickle

class DocumentClassificationCache:
    """文書分類結果キャッシュ"""
    
    def __init__(self, cache_size: int = 1000):
        self.cache_size = cache_size
        self._memory_cache = {}
    
    def _generate_cache_key(
        self, 
        text: str, 
        filename: str,
        settings: Dict[str, Any]
    ) -> str:
        """キャッシュキー生成"""
        content = f"{text}|{filename}|{str(sorted(settings.items()))}"
        return hashlib.sha256(content.encode()).hexdigest()[:16]
    
    @lru_cache(maxsize=1000)
    def get_classification_cached(
        self, 
        text_hash: str,
        filename: str,
        settings_hash: str
    ) -> Optional[Dict[str, Any]]:
        """キャッシュから分類結果取得"""
        cache_key = f"{text_hash}|{filename}|{settings_hash}"
        return self._memory_cache.get(cache_key)
    
    def set_classification_cache(
        self,
        text_hash: str,
        filename: str, 
        settings_hash: str,
        result: Dict[str, Any]
    ):
        """分類結果をキャッシュに保存"""
        cache_key = f"{text_hash}|{filename}|{settings_hash}"
        
        # LRU eviction
        if len(self._memory_cache) >= self.cache_size:
            oldest_key = next(iter(self._memory_cache))
            del self._memory_cache[oldest_key]
        
        self._memory_cache[cache_key] = result
```

### Phase 3: テスト・品質保証

#### 包括的テストスイート
```python
# 実装タスク: テストフレームワーク構築
import pytest
from unittest.mock import Mock, patch
from helpers.job_context import JobContext
from helpers.run_config import RunConfig

class TestTaxDocumentProcessing:
    """税務書類処理テストスイート"""
    
    @pytest.fixture
    def sample_job_context(self):
        run_config = RunConfig.from_ui_input("2508")
        return JobContext(
            job_id="test_job_001",
            confirmed_yymm="2508", 
            yymm_source="UI",
            run_config=run_config
        )
    
    @pytest.fixture
    def sample_pdf_file(self, tmp_path):
        """テスト用PDFファイル作成"""
        pdf_path = tmp_path / "test_document.pdf"
        # PDFファイル作成ロジック
        return pdf_path
    
    def test_ui_forced_code_validation(self, sample_job_context):
        """UI強制コード検証テスト"""
        # 6001コードでUI値が確実に適用されることを確認
        yymm = sample_job_context.get_yymm_for_classification("6001")
        assert yymm == "2508"
        
        # UI値がない場合のエラー確認
        empty_context = JobContext(
            job_id="test_empty",
            confirmed_yymm=None,
            yymm_source="NONE",
            run_config=None
        )
        
        with pytest.raises(ValueError, match="UI YYMM required"):
            empty_context.get_yymm_for_classification("6001")
    
    @pytest.mark.asyncio
    async def test_async_pdf_processing(
        self, 
        sample_pdf_file, 
        sample_job_context
    ):
        """非同期PDF処理テスト"""
        processor = AsyncPDFProcessor()
        result = await processor.process_pdf_async(
            sample_pdf_file, 
            sample_job_context
        )
        
        assert result is not None
        assert "processing_time" in result
        
    def test_bundle_split_propagation(self, sample_pdf_file):
        """Bundle分割でのRunConfig伝搬テスト"""
        # Bundle分割コールバックでRunConfig情報が
        # 確実に伝搬されることを確認
        pass
```

#### 統合テスト・E2Eテスト
```python
# 実装タスク: E2Eテストシナリオ
class TestTaxDocumentE2E:
    """エンドツーエンドテストスイート"""
    
    def test_complete_processing_workflow(self, tmp_path):
        """完全処理ワークフローテスト"""
        # 1. アプリケーション起動
        # 2. UI値設定 (2508)
        # 3. PDF処理実行
        # 4. UI強制コードファイル名確認
        # 5. Bundle分割結果確認
        # 6. ログ出力確認
        pass
        
    def test_error_recovery_scenarios(self):
        """エラー回復シナリオテスト"""
        # 1. UI値未設定エラー
        # 2. 不正ファイル形式エラー  
        # 3. Bundle分割失敗
        # 4. システムリソース不足
        pass
```

## 3. 実行ログ・進捗記録

### 実装進捗トラッキング
```python
# 実装タスク: 進捗記録システム
from datetime import datetime
from typing import Dict, List
import json

class ImplementationTracker:
    """実装進捗追跡システム"""
    
    def __init__(self, project_name: str):
        self.project_name = project_name
        self.start_time = datetime.now()
        self.tasks = []
        self.milestones = []
    
    def start_task(self, task_name: str, description: str):
        """タスク開始記録"""
        task = {
            "name": task_name,
            "description": description,
            "start_time": datetime.now().isoformat(),
            "status": "in_progress",
            "end_time": None,
            "duration": None,
            "notes": []
        }
        self.tasks.append(task)
        return len(self.tasks) - 1  # task index
    
    def complete_task(self, task_index: int, notes: str = ""):
        """タスク完了記録"""
        task = self.tasks[task_index]
        task["end_time"] = datetime.now().isoformat()
        task["status"] = "completed"
        task["duration"] = (
            datetime.fromisoformat(task["end_time"]) - 
            datetime.fromisoformat(task["start_time"])
        ).total_seconds()
        if notes:
            task["notes"].append(notes)
    
    def add_milestone(self, milestone_name: str, achievement: str):
        """マイルストーン記録"""
        milestone = {
            "name": milestone_name,
            "achievement": achievement,
            "timestamp": datetime.now().isoformat(),
            "completed_tasks": len([t for t in self.tasks if t["status"] == "completed"])
        }
        self.milestones.append(milestone)
    
    def generate_progress_report(self) -> str:
        """進捗レポート生成"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_path = f"tmp/implementation_progress_{timestamp}.md"
        
        total_tasks = len(self.tasks)
        completed_tasks = len([t for t in self.tasks if t["status"] == "completed"])
        progress_percentage = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
        
        report_data = {
            "project": self.project_name,
            "progress": f"{progress_percentage:.1f}%",
            "tasks": {
                "total": total_tasks,
                "completed": completed_tasks,
                "in_progress": len([t for t in self.tasks if t["status"] == "in_progress"])
            },
            "milestones": self.milestones,
            "detailed_tasks": self.tasks
        }
        
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(f"# {self.project_name} 実装進捗レポート\n\n")
            f.write(f"生成日時: {timestamp}\n")
            f.write(f"進捗率: {progress_percentage:.1f}%\n\n")
            f.write("```json\n")
            f.write(json.dumps(report_data, ensure_ascii=False, indent=2))
            f.write("\n```\n")
        
        return report_path

# 使用例
tracker = ImplementationTracker("税務書類リネーマー v5.3.5-ui-robust")

# Phase 0 実装
task_idx = tracker.start_task("型ヒント追加", "全モジュールに型ヒント適用")
# ... 実装作業 ...
tracker.complete_task(task_idx, "main.py, helpers/*.py完了")

tracker.add_milestone("Phase 0完了", "基盤整備完了・型安全性確立")
```

## 4. 品質チェック・コードレビュー

### 自動品質チェック
```bash
# 実装タスク: 品質チェック自動化
#!/bin/bash
# quality_check.sh

echo "🔍 税務書類リネーマー品質チェック開始"

# 型チェック
echo "📝 型チェック実行中..."
mypy --strict **/*.py

# コードスタイル
echo "🎨 コードスタイルチェック..."
black --check **/*.py
flake8 **/*.py

# テスト実行
echo "🧪 テスト実行中..."
pytest tests/ -v --cov=. --cov-report=html

# セキュリティチェック
echo "🔒 セキュリティチェック..."
bandit -r . -f json -o tmp/security_report.json

# 複雑度チェック
echo "📊 コード複雑度チェック..."
radon cc . --min B --json > tmp/complexity_report.json

echo "✅ 品質チェック完了"
```

### コードレビューチェックリスト
```yaml
レビュー観点:
  機能性:
    - [ ] UI強制コード（6001,6002,6003,0000）正常動作
    - [ ] Bundle分割でRunConfig伝搬確認
    - [ ] エラーハンドリング適切性
    - [ ] ログ出力妥当性
  
  品質:
    - [ ] 型ヒント完全適用
    - [ ] テストカバレッジ >= 90%
    - [ ] コード複雑度 <= 10
    - [ ] ドキュメント適切性
  
  セキュリティ:
    - [ ] 入力検証実装
    - [ ] 機密情報漏洩防止
    - [ ] ファイルアクセス制御
    - [ ] エラー情報適切制御
  
  パフォーマンス:
    - [ ] メモリリーク無し
    - [ ] 処理時間要件達成
    - [ ] リソース効率利用
    - [ ] スケーラビリティ考慮
```

## 5. 完了基準・検収条件

### 完了チェックリスト
```yaml
Phase 0 完了基準:
  - [ ] 型ヒント100%適用完了
  - [ ] エラーハンドリング体系構築
  - [ ] 構造化ログシステム導入
  - [ ] 自動テストスイート作成

Phase 1 完了基準:
  - [ ] サービス層分離完了
  - [ ] 依存性注入コンテナ構築
  - [ ] アーキテクチャリファクタリング
  - [ ] モジュール境界明確化

Phase 2 完了基準:
  - [ ] 非同期処理システム導入
  - [ ] キャッシュシステム実装
  - [ ] パフォーマンス目標達成
  - [ ] スケーラビリティ確保

全体完了基準:
  - [ ] 全テスト項目PASS
  - [ ] 品質メトリクス目標達成
  - [ ] セキュリティ要件充足
  - [ ] ドキュメント完備
```

### 検収シナリオ
```python
# 実装タスク: 受入テストシナリオ
def acceptance_test_scenario():
    """受入テスト完全シナリオ"""
    scenarios = [
        {
            "name": "UI=2508でのUI強制コード処理",
            "steps": [
                "アプリケーション起動",
                "YYMM値に2508を設定",
                "6001,6002,6003,0000を含むPDF処理",
                "確実な_2508ファイル名生成確認"
            ],
            "expected": "全UI強制コードで_2508ファイル生成"
        },
        {
            "name": "Bundle分割でのRunConfig伝搬",
            "steps": [
                "Bundle PDF準備",
                "UI値設定",
                "自動分割実行",
                "分割後各ファイルのYYMM値確認"
            ],
            "expected": "分割されたファイル全てにYYMM値伝搬"
        },
        {
            "name": "エラーハンドリング・回復",
            "steps": [
                "UI値未設定状態でUI強制コード処理",
                "適切なエラーメッセージ表示確認",
                "システム安定性確認"
            ],
            "expected": "適切なエラー処理・システム継続動作"
        }
    ]
    return scenarios
```

---

**実装モットー**: "Code with Pride, Test with Rigor, Deploy with Confidence！"  
**完了基準**: 全チェックリスト項目完了 + 受入テスト全PASS + 品質基準達成